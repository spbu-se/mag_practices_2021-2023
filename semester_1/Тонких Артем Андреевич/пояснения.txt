Эти методы уже давно сформулированы и реализованы во многих программных средствах, не спорю. Но есть нюансы.
1. Рунге-Кутта. Реализации, которые я находил (тот же scipy) имеют вид RK(fun, t0, y0, t_bound,...), 
где t_bound – крайнее время интегрирования. Т.е. метод Рунге-Кутты будет интегрировать до достижения этого t. 
В работе же подразумевается просчет не до достижения определенного времени, а до достижения определенного модуля 
искомого вектора r, ибо скорости звука надо подбирать, чтобы разница этих самых расчетных времён и реальных была 
минимальна. Подобных реализаций я не находил. Поэтому решено реализовать самим. 
2. Метод Левенберга-Марквардта. У меня был опыт работы с этим методом в рамках бакалаврской работы в среде Matlab. 
Тогда я подбирал около 20 параметров. И он весьма часто "глох" (долго искал параметры, застревал в минимуме). 
Здесь же речь идёт о 1000000 параметрах, и если подбирать их подобным образом, то ситуация может стать аналогичной. 
Python все же медленнее работает. Есть идея модифицировать этот метод: делать нелинейный расчет не на каждой итерации, 
а один в несколько раз, тем самым ускорив его. В отчёте это не указано, но уже идёт работа в этом направлении. 
Поэтому, опять-таки, решено делать его самим. 
3. Помимо всех этих методов есть другая задача. Дело в том, что количество данных колоссальное. 
Это явно потребует отдельной работы по экономии памяти. Так что работа заключается не только в реализациях численных методов. 
4. Выбор стоял между C и Python. Аспиранты моего руководителя уже имеют опыт в подобных задачах, 
и они используют для этого Python и библиотеку Pytorch для распараллеливания. Было решено пойти 
по этому же пути и в случае чего обращаться к ним, как к уже опытным пользователям. 
5. Цель состоит как в реализации методов и их модификации, так и в экономии памяти. Рунге-Кутта для 
просчета лучей, Левенберг-Марквардт для минимизации ошибки. 
6. http://viennacl.sourceforge.net/ вижу в первый раз, ознакомлюсь.